{
if(i%%10==0){print(noquote(paste('MCMC iter =',i)))}
# constructing fixed effect vector
alphas = rep(0,length(y))
for(j in 1:numi)
{
ind = alphaIDlist[[j]]
alphas[ind] = alphaMCMC[j,i-1]
}
# SAMPLE betas
BMCMC[,i] = as.numeric(sampleBmean(y-alphas,X,sig2MCMC[i-1],rep(tau2MCMC[,i-1],numi*numj),rep(muMCMC[,i-1],numi*numj)))
# SAMPLE sig2
sig2MCMC[i] = samplesig2mean(y-alphas,X,BMCMC[,i])
# SAMPLE the prior parameters on the betas .. mu and tau2 (both vectors)
for(j in 1:numpred)
{
predin = (loopind+j-1)
tau2MCMC[j,i] = sampletau2mean((BMCMC[predin,i]-muMCMC[j,i-1]))
muMCMC[j,i] = samplemumean(BMCMC[predin,i],tau2MCMC[j,i],m,sig02)
}
# sample prior parameter sigalpha2
# sigmalpha2MCMC[i] = samplesigmalpha2(alphaMCMC[,i-1])
sigmalpha2MCMC[i] = 5
# SAMPLE the country i level fixed effects (alphas)
for(j in 1:numi)
{
ind = alphaIDlist[[j]]
ymxB = y[ind] - X[ind,]%*%BMCMC[,i]
# alphaMCMC[j,i] = samplealpha(ymxB,sigmalpha2MCMC[i],sig2MCMC[i])
alphaMCMC[j,i] = samplemumean(ymxB,sig2MCMC[i],m = 0,sigmalpha2MCMC[i])
}
}
return(list(BMCMC,sig2MCMC,tau2MCMC,muMCMC,alphaMCMC,sigmalpha2MCMC))
}
results = Gibbswrapper(loops,y,X,numi,numj,alphaIDlist)
BMCMC = results[[1]]
sig2MCMC = results[[2]]
tau2MCMC = results[[3]]
muMCMC = results[[4]]
alphaMCMC = results[[5]]
sigmalpha2MCMC = results[[6]]
plot(sig2MCMC[10:loops],type='l',col=2)
plot(sigmalpha2MCMC[loops/2:loops],type='l',col=5)
plot(tau2MCMC[1,loops/2:loops],type='l')
plot(tau2MCMC[2,loops/2:loops],type='l')
plot(tau2MCMC[3,loops/2:loops],type='l')
plot(muMCMC[1,loops/2:loops],type='l')
plot(muMCMC[2,loops/2:loops],type='l')
plot(muMCMC[3,loops/2:loops],type='l')
sigmalpha2MCMC
samplealpha()
samplealpha
samplemumean
source('GibbsSamplingFunctionsKent.R')
results = Gibbswrapper(loops,y,X,numi,numj,alphaIDlist)
source('GibbsSamplingFunctionsKent.R')
results = Gibbswrapper(loops,y,X,numi,numj,alphaIDlist)
BMCMC = results[[1]]
sig2MCMC = results[[2]]
tau2MCMC = results[[3]]
muMCMC = results[[4]]
alphaMCMC = results[[5]]
sigmalpha2MCMC = results[[6]]
sigmalpha2MCMC
plot(sig2MCMC[10:loops],type='l',col=2)
plot(sigmalpha2MCMC[loops/2:loops],type='l',col=5)
plot(tau2MCMC[1,loops/2:loops],type='l')
plot(tau2MCMC[2,loops/2:loops],type='l')
plot(tau2MCMC[3,loops/2:loops],type='l')
plot(muMCMC[1,loops/2:loops],type='l')
plot(muMCMC[2,loops/2:loops],type='l')
plot(muMCMC[3,loops/2:loops],type='l')
y=rep(0,300)
xsim = rnorm(300,3,4)
xsim
lm(y~X)
y
# removing missing data
nas = unique(c(which(is.na(newmac$dexp_share)),which(is.na(newmac$dfx)),which(is.na(newmac$dgdp)),which(is.na(newmac$dcomp))))
newmac2 = newmac[-nas,]
M = dim(newmac2)[1]
# construct X
numcovar = 3
size = numcovar*length(ucountj)*length(ucounti)
loopind = seq(from = 1,to = size,by = numcovar)
X = Matrix(matrix(0,M,size),sparse=T) #using sparse matrix class
# indicies for each i and j pair
indlist = list()
k=1
for(i in 1:length(ucounti))
{
for(j in 1:length(ucountj))
{
indlist[[k]] = intersect(which(newmac2$country_j==ucountj[j]),which(newmac2$country_i==ucounti[i]))
k=k+1
}
}
# constructing the covariates
countrypairnum = 1
for(i in loopind)
{
ind = indlist[[countrypairnum]]
X[ind,i] = newmac2$dfx[ind]
X[ind,i+1] = newmac2$dcomp[ind]
X[ind,i+2] = newmac2$dgdp[ind]
countrypairnum=countrypairnum+1
}
# saving the response as y
y = newmac2$dexp_share
lm(y~X)
lm(y~as.matrix(X))
# Functions ---------------------------------------------------------------
L <- function(x, k)
{
c(rep(NA, k), x)[1 : length(x)]
}
deseasonalizeQ <- function (x)
{
x <- ts(x)
#Step1: Centered moving averages: create cma time series having the same length with the original time series x
# cma has 2 NAs on both ends.
cma <- filter(x, filter = c(1/8, 1/4, 1/4, 1/4, 1/8), sides=2)
#Step2: Ratios = Original time series / centered moving averages
ratio <- x/cma
#Step3: Unadjusted 4 seasonal indexes
unadj4si <- ts(1:4)
# floor((length(x)-4)/4)  #"-4" is 4 NA at both ends; below "-1" is due to starting "0:" in multiplication
unadj4si[1] <- mean(ratio[3+4*(0:(floor((length(x)-4)/4) - 1))])
unadj4si[2] <- mean(ratio[4+4*(0:(floor((length(x)-4)/4) - 1))])
unadj4si[3] <- mean(ratio[5+4*(0:(floor((length(x)-4)/4) - 1))])
unadj4si[4] <- mean(ratio[6+4*(0:(floor((length(x)-4)/4) - 1))])
#Step4: Adjusted 4 seasonal indexes
adj4si <- ts(1:4)
adj4si[1] <- unadj4si[1]/mean(c(unadj4si[1],unadj4si[2],unadj4si[3],unadj4si[4]))
adj4si[2] <- unadj4si[2]/mean(c(unadj4si[1],unadj4si[2],unadj4si[3],unadj4si[4]))
adj4si[3] <- unadj4si[3]/mean(c(unadj4si[1],unadj4si[2],unadj4si[3],unadj4si[4]))
adj4si[4] <- unadj4si[4]/mean(c(unadj4si[1],unadj4si[2],unadj4si[3],unadj4si[4]))
#Step5: Propogated adjusted seasonal indexes
propadjsi <- ts(1:length(x))
propadjsi[3+4*(0:(floor((length(x)-4)/4) - 1))] <- adj4si[1]
propadjsi[4+4*(0:(floor((length(x)-4)/4) - 1))] <- adj4si[2]
propadjsi[5+4*(0:(floor((length(x)-4)/4) - 1))] <- adj4si[3]
propadjsi[6+4*(0:(floor((length(x)-4)/4) - 1))] <- adj4si[4]
propadjsi[1] <- adj4si[3]
propadjsi[2] <- adj4si[4]
propadjsi[length(x)-1] <- adj4si[1]
propadjsi[length(x)] <- adj4si[2]
#Step6: Deseasonalized values
out <- x/propadjsi  # deseasonalized = x/propadjsi
return(out)
}
deseasonalizeDavidQ = function(x)
{
Time = 1:length(x)
N = rep(1:4,length(x)/4)
Q1 = (N==1)
Q2 = (N==2)
Q3 = (N==3)
fit = lm(x~Time+Q1+Q2+Q3)
alpha = fit$coefficients[1]
beta = fit$coefficients[2]
deseason = alpha + beta*Time + fit$residuals
return(deseason)
}
# Data --------------------------------------------------------------------
N = dim(mac)[1]
# unique values
ucountj = unique(mac$country_j)
ucounti = unique(mac$country_i)
udate = unique(mac$date)
# order by country j
newmac = mac[order(mac$country_j),]
# adding some variables
newmac$exp_share = (newmac$exp / newmac$exp_wld)*100
newmac$fx = newmac$fx_i / newmac$fx_j
newmac$comp = newmac$reer_i / newmac$reer_j
# making change in export share, fx, comp, gdp variables variable (quarterly)
newmac$dexp_share = rep(0,N)
newmac$dfx = rep(0,N)
newmac$dcomp = rep(0,N)
newmac$dgdp = rep(0,N)
for(i in 1:length(ucounti))
{
for(j in 1:length(ucountj))
{
ind = intersect(which(newmac$country_j==ucountj[j]),which(newmac$country_i==ucounti[i]))
# export share change for all i and j
exp_share = newmac$exp_share[ind]
newmac$dexp_share[ind] = log(exp_share) - log(L(exp_share,1))
# fx change for all i and j
fx = newmac$fx[ind]
newmac$dfx[ind] = log( (1 - ((fx)/(L(fx,1)))) + 1 )
# comp change for all i and j
comp = newmac$comp[ind]
newmac$dcomp[ind] = log(comp) - log(L(comp,1))
# gdp change for all i and j
gdp = newmac$comp[ind]
newmac$dgdp[ind] = log( ((gdp)/(L(gdp,1)) - 1) + 1 )
}
}
# Building design matrix --------------------------------------------------
fx
View(newmac2)
View(newmac)
## playing around with data ##
library(foreign)
library(zoo)
library(plm)
library(Matrix)
setwd("~/Documents/Kent/BayesianMacro")
source('GibbsSamplingFunctionsKent.R')
mac = read.dta('quarterly.dta')
# Functions ---------------------------------------------------------------
L <- function(x, k)
{
c(rep(NA, k), x)[1 : length(x)]
}
deseasonalizeQ <- function (x)
{
x <- ts(x)
#Step1: Centered moving averages: create cma time series having the same length with the original time series x
# cma has 2 NAs on both ends.
cma <- filter(x, filter = c(1/8, 1/4, 1/4, 1/4, 1/8), sides=2)
#Step2: Ratios = Original time series / centered moving averages
ratio <- x/cma
#Step3: Unadjusted 4 seasonal indexes
unadj4si <- ts(1:4)
# floor((length(x)-4)/4)  #"-4" is 4 NA at both ends; below "-1" is due to starting "0:" in multiplication
unadj4si[1] <- mean(ratio[3+4*(0:(floor((length(x)-4)/4) - 1))])
unadj4si[2] <- mean(ratio[4+4*(0:(floor((length(x)-4)/4) - 1))])
unadj4si[3] <- mean(ratio[5+4*(0:(floor((length(x)-4)/4) - 1))])
unadj4si[4] <- mean(ratio[6+4*(0:(floor((length(x)-4)/4) - 1))])
#Step4: Adjusted 4 seasonal indexes
adj4si <- ts(1:4)
adj4si[1] <- unadj4si[1]/mean(c(unadj4si[1],unadj4si[2],unadj4si[3],unadj4si[4]))
adj4si[2] <- unadj4si[2]/mean(c(unadj4si[1],unadj4si[2],unadj4si[3],unadj4si[4]))
adj4si[3] <- unadj4si[3]/mean(c(unadj4si[1],unadj4si[2],unadj4si[3],unadj4si[4]))
adj4si[4] <- unadj4si[4]/mean(c(unadj4si[1],unadj4si[2],unadj4si[3],unadj4si[4]))
#Step5: Propogated adjusted seasonal indexes
propadjsi <- ts(1:length(x))
propadjsi[3+4*(0:(floor((length(x)-4)/4) - 1))] <- adj4si[1]
propadjsi[4+4*(0:(floor((length(x)-4)/4) - 1))] <- adj4si[2]
propadjsi[5+4*(0:(floor((length(x)-4)/4) - 1))] <- adj4si[3]
propadjsi[6+4*(0:(floor((length(x)-4)/4) - 1))] <- adj4si[4]
propadjsi[1] <- adj4si[3]
propadjsi[2] <- adj4si[4]
propadjsi[length(x)-1] <- adj4si[1]
propadjsi[length(x)] <- adj4si[2]
#Step6: Deseasonalized values
out <- x/propadjsi  # deseasonalized = x/propadjsi
return(out)
}
deseasonalizeDavidQ = function(x)
{
Time = 1:length(x)
N = rep(1:4,length(x)/4)
Q1 = (N==1)
Q2 = (N==2)
Q3 = (N==3)
fit = lm(x~Time+Q1+Q2+Q3)
alpha = fit$coefficients[1]
beta = fit$coefficients[2]
deseason = alpha + beta*Time + fit$residuals
return(deseason)
}
# Data --------------------------------------------------------------------
N = dim(mac)[1]
# unique values
ucountj = unique(mac$country_j)
ucounti = unique(mac$country_i)
udate = unique(mac$date)
# order by country j
newmac = mac[order(mac$country_j),]
# adding some variables
newmac$exp_share = (newmac$exp / newmac$exp_wld)*100
newmac$fx = newmac$fx_i / newmac$fx_j
newmac$comp = newmac$reer_i / newmac$reer_j
# making change in export share, fx, comp, gdp variables variable (quarterly)
newmac$dexp_share = rep(0,N)
newmac$dfx = rep(0,N)
newmac$dcomp = rep(0,N)
newmac$dgdp = rep(0,N)
for(i in 1:length(ucounti))
{
for(j in 1:length(ucountj))
{
ind = intersect(which(newmac$country_j==ucountj[j]),which(newmac$country_i==ucounti[i]))
# export share change for all i and j
exp_share = newmac$exp_share[ind]
newmac$dexp_share[ind] = log(exp_share) - log(L(exp_share,1))
# fx change for all i and j
fx = newmac$fx[ind]
newmac$dfx[ind] = log( (1 - ((fx)/(L(fx,1)))) + 1 )
# comp change for all i and j
comp = newmac$comp[ind]
newmac$dcomp[ind] = log(comp) - log(L(comp,1))
# gdp change for all i and j
gdp = newmac$comp[ind]
newmac$dgdp[ind] = log( ((gdp)/(L(gdp,1)) - 1) + 1 )
}
}
i
j
newmac$dfx
is.nan(newmac$dfx)
sum(is.nan(newmac$dfx))
which(is.nan(newmac$dfx)==TRUE)
newmac$fx[10339]
newmac$fx_i[10339]
newmac$fx_j[10339]
which(is.nan(newmac$dfx))
## playing around with data ##
library(foreign)
library(zoo)
library(plm)
library(Matrix)
setwd("~/Documents/Kent/BayesianMacro")
source('GibbsSamplingFunctionsKent.R')
mac = read.dta('quarterly.dta')
# Functions ---------------------------------------------------------------
L <- function(x, k)
{
c(rep(NA, k), x)[1 : length(x)]
}
deseasonalizeQ <- function (x)
{
x <- ts(x)
#Step1: Centered moving averages: create cma time series having the same length with the original time series x
# cma has 2 NAs on both ends.
cma <- filter(x, filter = c(1/8, 1/4, 1/4, 1/4, 1/8), sides=2)
#Step2: Ratios = Original time series / centered moving averages
ratio <- x/cma
#Step3: Unadjusted 4 seasonal indexes
unadj4si <- ts(1:4)
# floor((length(x)-4)/4)  #"-4" is 4 NA at both ends; below "-1" is due to starting "0:" in multiplication
unadj4si[1] <- mean(ratio[3+4*(0:(floor((length(x)-4)/4) - 1))])
unadj4si[2] <- mean(ratio[4+4*(0:(floor((length(x)-4)/4) - 1))])
unadj4si[3] <- mean(ratio[5+4*(0:(floor((length(x)-4)/4) - 1))])
unadj4si[4] <- mean(ratio[6+4*(0:(floor((length(x)-4)/4) - 1))])
#Step4: Adjusted 4 seasonal indexes
adj4si <- ts(1:4)
adj4si[1] <- unadj4si[1]/mean(c(unadj4si[1],unadj4si[2],unadj4si[3],unadj4si[4]))
adj4si[2] <- unadj4si[2]/mean(c(unadj4si[1],unadj4si[2],unadj4si[3],unadj4si[4]))
adj4si[3] <- unadj4si[3]/mean(c(unadj4si[1],unadj4si[2],unadj4si[3],unadj4si[4]))
adj4si[4] <- unadj4si[4]/mean(c(unadj4si[1],unadj4si[2],unadj4si[3],unadj4si[4]))
#Step5: Propogated adjusted seasonal indexes
propadjsi <- ts(1:length(x))
propadjsi[3+4*(0:(floor((length(x)-4)/4) - 1))] <- adj4si[1]
propadjsi[4+4*(0:(floor((length(x)-4)/4) - 1))] <- adj4si[2]
propadjsi[5+4*(0:(floor((length(x)-4)/4) - 1))] <- adj4si[3]
propadjsi[6+4*(0:(floor((length(x)-4)/4) - 1))] <- adj4si[4]
propadjsi[1] <- adj4si[3]
propadjsi[2] <- adj4si[4]
propadjsi[length(x)-1] <- adj4si[1]
propadjsi[length(x)] <- adj4si[2]
#Step6: Deseasonalized values
out <- x/propadjsi  # deseasonalized = x/propadjsi
return(out)
}
deseasonalizeDavidQ = function(x)
{
Time = 1:length(x)
N = rep(1:4,length(x)/4)
Q1 = (N==1)
Q2 = (N==2)
Q3 = (N==3)
fit = lm(x~Time+Q1+Q2+Q3)
alpha = fit$coefficients[1]
beta = fit$coefficients[2]
deseason = alpha + beta*Time + fit$residuals
return(deseason)
}
# Data --------------------------------------------------------------------
N = dim(mac)[1]
# unique values
ucountj = unique(mac$country_j)
ucounti = unique(mac$country_i)
udate = unique(mac$date)
# order by country j
newmac = mac[order(mac$country_j),]
# adding some variables
newmac$exp_share = (newmac$exp / newmac$exp_wld)*100
newmac$fx = newmac$fx_i / newmac$fx_j
newmac$comp = newmac$reer_i / newmac$reer_j
# making change in export share, fx, comp, gdp variables variable (quarterly)
newmac$dexp_share = rep(0,N)
newmac$dfx = rep(0,N)
newmac$dcomp = rep(0,N)
newmac$dgdp = rep(0,N)
for(i in 1:length(ucounti))
{
for(j in 1:length(ucountj))
{
ind = intersect(which(newmac$country_j==ucountj[j]),which(newmac$country_i==ucounti[i]))
# export share change for all i and j
exp_share = newmac$exp_share[ind]
newmac$dexp_share[ind] = log(exp_share) - log(L(exp_share,1))
# fx change for all i and j
fx = newmac$fx[ind]
newmac$dfx[ind] = log( (1 - ((fx)/(L(fx,1)))) + 1 )
# comp change for all i and j
comp = newmac$comp[ind]
newmac$dcomp[ind] = log(comp) - log(L(comp,1))
# gdp change for all i and j
gdp = newmac$comp[ind]
newmac$dgdp[ind] = log( ((gdp)/(L(gdp,1)) - 1) + 1 )
}
}
# Building design matrix --------------------------------------------------
# removing missing data
nas = unique(c(which(is.na(newmac$dexp_share)),which(is.na(newmac$dfx)),which(is.na(newmac$dgdp)),which(is.na(newmac$dcomp)),which(is.nan(newmac$dfx))))
newmac2 = newmac[-nas,]
M = dim(newmac2)[1]
# construct X
numcovar = 3
size = numcovar*length(ucountj)*length(ucounti)
loopind = seq(from = 1,to = size,by = numcovar)
X = Matrix(matrix(0,M,size),sparse=T) #using sparse matrix class
# indicies for each i and j pair
indlist = list()
k=1
for(i in 1:length(ucounti))
{
for(j in 1:length(ucountj))
{
indlist[[k]] = intersect(which(newmac2$country_j==ucountj[j]),which(newmac2$country_i==ucounti[i]))
k=k+1
}
}
# constructing the covariates
countrypairnum = 1
for(i in loopind)
{
ind = indlist[[countrypairnum]]
X[ind,i] = newmac2$dfx[ind]
X[ind,i+1] = newmac2$dcomp[ind]
X[ind,i+2] = newmac2$dgdp[ind]
countrypairnum=countrypairnum+1
}
# saving the response as y
y = newmac2$dexp_share
numi = length(ucounti)
numj = length(ucountj)
loops = 100
alphaIDlist = list()
for(i in 1:length(ucounti))
{
alphaIDlist[[i]] = which(newmac2$country_i==ucounti[i])
}
source('GibbsSamplingFunctionsKent.R')
results = Gibbswrapper(loops,y,X,numi,numj,alphaIDlist)
BMCMC = results[[1]]
sig2MCMC = results[[2]]
tau2MCMC = results[[3]]
muMCMC = results[[4]]
alphaMCMC = results[[5]]
sigmalpha2MCMC = results[[6]]
sum(is.na(X))
sum(is.nan(X))
sum(is.nan(as.matrix(X)))
sum(is.infinite(as.matrix(X)))
sum(is.inf(as.matrix(X)))
X
sv(X)
svd(X)
results = Gibbswrapper(loops,y,X,numi,numj,alphaIDlist)
test=t(X)%*%X
svd(test)
source('GibbsSamplingFunctionsKent.R')
results = Gibbswrapper(loops,y,X,numi,numj,alphaIDlist)
source('GibbsSamplingFunctionsKent.R')
results = Gibbswrapper(loops,y,X,numi,numj,alphaIDlist)
sig2MCMC
y-alphas
alphas
BMCMC[,1]
BMCMC[,2]
source('GibbsSamplingFunctionsKent.R')
results = Gibbswrapper(loops,y,X,numi,numj,alphaIDlist)
BMCMC[,2]
BMCMC[,2]
source('GibbsSamplingFunctionsKent.R')
results = Gibbswrapper(loops,y,X,numi,numj,alphaIDlist)
Tmat
Tmatinv
tau2
sig2
SIG1inv
m
SIG1
mu
t(X)%*%y
SIG1%*%t(X)%*%y
is.nan(SIG1inv)
is.nan(as.matrix(SIG1inv))
sum(is.nan(as.matrix(SIG1inv)))
sig2
test=solve(SIG1)
test
sum(is.nan(test))
test=solve(SIG1inv)
sum(is.nan(test))
sum(is.nan(as.matrix(test)))
source('GibbsSamplingFunctionsKent.R')
results = Gibbswrapper(loops,y,X,numi,numj,alphaIDlist)
BMCMC[,2]
BMCMC[,3]
BMCMC[,1]
BMCMC[,2]
tau2MCMC[2]
source('GibbsSamplingFunctionsKent.R')
results = Gibbswrapper(loops,y,X,numi,numj,alphaIDlist)
