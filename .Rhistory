{
Time = 1:length(x)
N = rep(1:4,length(x)/4)
Q1 = (N==1)
Q2 = (N==2)
Q3 = (N==3)
fit = lm(x~Time+Q1+Q2+Q3)
alpha = fit$coefficients[1]
beta = fit$coefficients[2]
deseason = alpha + beta*Time + fit$residuals
return(deseason)
}
# Data --------------------------------------------------------------------
N = dim(mac)[1]
# unique values
ucountj = unique(mac$country_j)
ucounti = unique(mac$country_i)
udate = unique(mac$date)
# order by country j
newmac = mac[order(mac$country_j),]
# adding some variables
newmac$exp_share = (newmac$exp / newmac$exp_wld)*100
newmac$fx = newmac$fx_i / newmac$fx_j
newmac$comp = newmac$reer_i / newmac$reer_j
# making change in export share, fx, comp, gdp variables variable (quarterly)
newmac$dexp_share = rep(0,N)
newmac$dfx = rep(0,N)
newmac$dcomp = rep(0,N)
newmac$dgdp = rep(0,N)
for(i in 1:length(ucounti))
{
for(j in 1:length(ucountj))
{
ind = intersect(which(newmac$country_j==ucountj[j]),which(newmac$country_i==ucounti[i]))
# export share change for all i and j
exp_share = newmac$exp_share[ind]
newmac$dexp_share[ind] = exp_share - L(exp_share,1)
# fx change for all i and j
fx = newmac$fx[ind]
newmac$dfx[ind] = (1 - (fx/L(fx,1)))*100
# comp change for all i and j
comp = newmac$comp[ind]
newmac$dcomp[ind] = comp - L(comp,1)
# gdp change for all i and j
gdp = newmac$comp[ind]
newmac$dgdp[ind] = (gdp/L(gdp,1) - 1)*100
}
}
numcovar = 4
size = numcovar*length(ucountj)
loopind = seq(from = 1,to = size,by = numcovar)
BIGX = Matrix(matrix(0,N,size),sparse=T) #using sparse matrix class
View(newmac)
indlist = list()
indlist = list()
k=1
for(i in 1:length(ucounti))
{
for(j in 1:length(ucountj))
{
indlist[[k]] = intersect(which(newmac$country_j==ucountj[j]),which(newmac$country_i==ucounti[i]))
k=k+1
}
}
indlist[[1]]
indlist[[2]]
indlist[[10]]
ucounti
ucountj
indlist[[4]]
length(indlist)
M = dim(newmac)[2]
M = dim(newmac)[1]
M = dim(newmac)[1]
const = rep(0,M)
fxlong = rep(0,M)
complong = rep(0,M)
gdplong = rep(0,M)
dim(BIGX)
size = numcovar*length(ucountj)*length(ucounti)
loopind = seq(from = 1,to = size,by = numcovar)
BIGX = Matrix(matrix(0,N,size),sparse=T) #using sparse matrix class
# constructing the covariates
M = dim(newmac)[1]
const = rep(0,M)
fxlong = rep(0,M)
complong = rep(0,M)
gdplong = rep(0,M)
y
y = newmac$dexp_share
numcovar = 4
size = numcovar*length(ucountj)*length(ucounti)
loopind = seq(from = 1,to = size,by = numcovar)
BIGX = Matrix(matrix(0,N-1,size),sparse=T) #using sparse matrix class
indlist = list()
k=1
for(i in 1:length(ucounti))
{
for(j in 1:length(ucountj))
{
indlist[[k]] = intersect(which(newmac$country_j==ucountj[j]),which(newmac$country_i==ucounti[i]))
k=k+1
}
}
const = rep(0,N-1)
fxlong = rep(0,N-1)
complong = rep(0,N-1)
gdplong = rep(0,N-1)
const = rep(0,N-1)
fxlong = rep(0,N-1)
complong = rep(0,N-1)
gdplong = rep(0,N-1)
for(i in length(loopind))
{
ind = indlist[[i]]
BIGX[ind,i] = const[ind]
BIGX[ind,i+1] = log(newmac$dfx)
BIGX[ind,i+2] = log(newmac$dcomp)
BIGX[ind,i+3] = log(newmac$dgdp)
}
# constructing the covariates
const = rep(0,N-1)
fxlong = rep(0,N-1)
complong = rep(0,N-1)
gdplong = rep(0,N-1)
for(i in loopind)
{
ind = indlist[[i]]
BIGX[ind,i] = const[ind]
BIGX[ind,i+1] = log(newmac$dfx)
BIGX[ind,i+2] = log(newmac$dcomp)
BIGX[ind,i+3] = log(newmac$dgdp)
}
# construct X
numcovar = 4
size = numcovar*length(ucountj)*length(ucounti)
loopind = seq(from = 1,to = size,by = numcovar)
BIGX = Matrix(matrix(0,N-1,size),sparse=T) #using sparse matrix class
# indicies for each i and j pair
indlist = list()
k=1
for(i in 1:length(ucounti))
{
for(j in 1:length(ucountj))
{
indlist[[k]] = intersect(which(newmac$country_j==ucountj[j]),which(newmac$country_i==ucounti[i]))
k=k+1
}
}
# constructing the covariates
const = rep(0,N-1)
fxlong = rep(0,N-1)
complong = rep(0,N-1)
gdplong = rep(0,N-1)
ind
const = rep(1,N-1)
const = rep(1,N-1)
for(i in loopind)
{
ind = indlist[[i]]
ind = ind[2:length(ind)]
BIGX[ind,i] = const[ind]
BIGX[ind,i+1] = log(newmac$dfx)
BIGX[ind,i+2] = log(newmac$dcomp)
BIGX[ind,i+3] = log(newmac$dgdp)
}
ind
const = rep(1,N-1)
for(i in loopind)
{
ind = indlist[[i]]
ind = ind[2:length(ind)]
BIGX[ind-1,i] = const[ind]
BIGX[ind-1,i+1] = log(newmac$dfx)
BIGX[ind-1,i+2] = log(newmac$dcomp)
BIGX[ind-1,i+3] = log(newmac$dgdp)
}
ind
ind = indlist[[i]]
ind
y = newmac$dexp_share
length(y)
which(is.na(newmac$dexp_share))
is.na(newmac$dexp_share)
sum(is.na(newmac$dexp_share))
sum(is.na(newmac$dfx))
sum(is.na(newmac$dcomp))
sum(is.na(newmac$dgdp))
union(which(is.na(newmac$dexp_share)),which(is.na(newmac$dfx)),which(is.na(newmac$dgdp)),which(is.na(newmac$dcomp)))
union(c(which(is.na(newmac$dexp_share)),which(is.na(newmac$dfx)),which(is.na(newmac$dgdp)),which(is.na(newmac$dcomp))))
union(c(which(is.na(newmac$dexp_share)),c(which(is.na(newmac$dfx)),which(is.na(newmac$dgdp)),which(is.na(newmac$dcomp))))
union(c(which(is.na(newmac$dexp_share)),c(which(is.na(newmac$dfx)),which(is.na(newmac$dgdp)),which(is.na(newmac$dcomp)))))
union(which(is.na(newmac$dexp_share)),which(is.na(newmac$dfx)),which(is.na(newmac$dgdp)),which(is.na(newmac$dcomp)))
which(is.na(newmac$dexp_share))
which(is.na(newmac$dfx))
which(is.na(newmac$dgdp))
which(is.na(newmac$dcomp))
unique(c(which(is.na(newmac$dexp_share)),which(is.na(newmac$dfx)),which(is.na(newmac$dgdp)),which(is.na(newmac$dcomp))))
nas = unique(c(which(is.na(newmac$dexp_share)),which(is.na(newmac$dfx)),which(is.na(newmac$dgdp)),which(is.na(newmac$dcomp))))
newmac2 = newmac[-nas,]
M = dim(newmac2)[1]
const = rep(1,M)
numcovar = 4
size = numcovar*length(ucountj)*length(ucounti)
loopind = seq(from = 1,to = size,by = numcovar)
BIGX = Matrix(matrix(0,M,size),sparse=T) #using sparse matrix class
dim(BIGX)
# indicies for each i and j pair
indlist = list()
k=1
for(i in 1:length(ucounti))
{
for(j in 1:length(ucountj))
{
indlist[[k]] = intersect(which(newmac$country_j==ucountj[j]),which(newmac$country_i==ucounti[i]))
k=k+1
}
}
const = rep(1,M)
# construct X
numcovar = 4
size = numcovar*length(ucountj)*length(ucounti)
loopind = seq(from = 1,to = size,by = numcovar)
BIGX = Matrix(matrix(0,M,size),sparse=T) #using sparse matrix class
# indicies for each i and j pair
indlist = list()
k=1
for(i in 1:length(ucounti))
{
for(j in 1:length(ucountj))
{
indlist[[k]] = intersect(which(newmac2$country_j==ucountj[j]),which(newmac2$country_i==ucounti[i]))
k=k+1
}
}
const = rep(1,M)
for(i in loopind)
{
ind = indlist[[i]]
BIGX[ind,i] = const[ind]
BIGX[ind,i+1] = newmac$dfx[ind]
BIGX[ind,i+2] = newmac$dcomp[ind]
BIGX[ind,i+3] = newmac$dgdp[ind]
}
loopind
const = rep(1,M)
countrypairnum = 1
for(i in loopind)
{
ind = indlist[[countrypairnum]]
BIGX[ind,i] = const[ind]
BIGX[ind,i+1] = newmac$dfx[ind]
BIGX[ind,i+2] = newmac$dcomp[ind]
BIGX[ind,i+3] = newmac$dgdp[ind]
countrypairnum=countrypairnum+1
}
y = newmac2$dexp_share
dim(BIGX)
length(y)
BIGX[1,]
BIGX[,1]
sum(BIGX[,1])
sum(BIGX[,5])
sum(BIGX[,9])
sum(BIGX[,13])
BIGX[1,]
loopind
length(BIGX)
dim(BIGX)
ind=indlist[[4]]
ind
const[ind]
BIGX[ind,13]
BIGX[ind,14]
View(newmac2)
# constructing the covariates
const = rep(1,M)
countrypairnum = 1
for(i in loopind)
{
ind = indlist[[countrypairnum]]
BIGX[ind,i] = const[ind]
BIGX[ind,i+1] = newmac2$dfx[ind]
BIGX[ind,i+2] = newmac2$dcomp[ind]
BIGX[ind,i+3] = newmac2$dgdp[ind]
countrypairnum=countrypairnum+1
}
BIGX[1,]
setwd("~/Documents/Kent/BayesianMacro")
source('Kent.R')
source('Kent.R')
source('Kent.R')
install.packages("lars")
source('Kent.R')
install.packages("truncnorm")
source('Kent.R')
install.packages("MCMCpack")
source('Kent.R')
m = 0
sig02 = 50
# other stuff
size = dim(X)[2]
numpred = size / (numi*numj)
BMCMC = matrix(0,size,loops)
sig2MCMC = rep(0,loops)
names(sig2MCMC) = rep('sig2',length(sig2MCMC))
tau2MCMC = matrix(0,numpred,loops)
muMCMC = matrix(0,numpred,loops)
alphaMCMC = matrix(0,numi,loops)
sigalpha2MCMC = rep(0,loops)
rownames(tau2MCMC) = paste('tau2',1:numpred)
rownames(muMCMC) = paste('mu',1:numpred)
BMCMC[,1] = rep(1,size)
sig2MCMC[1] = 1
tau2MCMC[,1] = rep(1,numpred)
muMCMC[,1] = rep(1,numpred)
alphaMCMC = rep(1,numi)
loopind = seq(from = 1,to = size,by = numpred)
for(i in 2:loops)
{
if(i%%50==0){print(noquote(paste('MCMC iter =',i)))}
# constructing fixed effect vector
alphas = rep(0,length(y))
for(j in 1:numi)
{
ind = alphaIDlist[[j]]
alphas[ind] = alphaMCMC[j,i-1]
}
# SAMPLE betas
BMCMC[,i] = as.numeric(sampleBmean(y-alphas,X,sig2MCMC[i-1],rep(tau2MCMC[,i-1],numi*numj),rep(muMCMC[,i-1],numi*numj)))
# SAMPLE sig2
sig2MCMC[i] = samplesig2mean(y-alphas,X,BMCMC[,i])
# SAMPLE the prior parameters on the betas .. mu and tau2 (both vectors)
for(j in 1:numpred)
{
predin = (loopind+j-1)
tau2MCMC[j,i] = sampletau2mean(y-alphas,(BMCMC[predin,i]-muMCMC[j,i-1]))
muMCMC[j,i] = samplemumean(y-alphas,BMCMC[predin,i],sig2MCMC[i],tau2MCMC[j,i],m,sig02)
}
# sample prior parameter sigalpha2
sigmalpha2MCMC[i] = samplesigalpha2(alphaMCMC[,i-1])
# SAMPLE the country i level fixed effects (alphas)
for(j in 1:numi)
{
ind = alphaIDlist[[j]]
yxmB = y[ind] - X[ind,]%*%BMCMC[,i]
alphaMCMC[j,i] = samplealpha(yxmB,sigmalpha2MCMC[i])
}
}
return(list(BMCMC,sig2MCMC,tau2MCMC,muMCMC))
}
# prior on mui
m = 0
sig02 = 50
# other stuff
size = dim(X)[2]
numpred = size / (numi*numj)
BMCMC = matrix(0,size,loops)
sig2MCMC = rep(0,loops)
names(sig2MCMC) = rep('sig2',length(sig2MCMC))
tau2MCMC = matrix(0,numpred,loops)
muMCMC = matrix(0,numpred,loops)
alphaMCMC = matrix(0,numi,loops)
sigalpha2MCMC = rep(0,loops)
rownames(tau2MCMC) = paste('tau2',1:numpred)
rownames(muMCMC) = paste('mu',1:numpred)
# starting points for MCMC
BMCMC[,1] = rep(1,size)
sig2MCMC[1] = 1
tau2MCMC[,1] = rep(1,numpred)
muMCMC[,1] = rep(1,numpred)
alphaMCMC[,1] = rep(1,numi)
loopind = seq(from = 1,to = size,by = numpred)
for(i in 2:loops)
{
if(i%%50==0){print(noquote(paste('MCMC iter =',i)))}
# constructing fixed effect vector
alphas = rep(0,length(y))
for(j in 1:numi)
{
ind = alphaIDlist[[j]]
alphas[ind] = alphaMCMC[j,i-1]
}
# SAMPLE betas
BMCMC[,i] = as.numeric(sampleBmean(y-alphas,X,sig2MCMC[i-1],rep(tau2MCMC[,i-1],numi*numj),rep(muMCMC[,i-1],numi*numj)))
# SAMPLE sig2
sig2MCMC[i] = samplesig2mean(y-alphas,X,BMCMC[,i])
# SAMPLE the prior parameters on the betas .. mu and tau2 (both vectors)
for(j in 1:numpred)
{
predin = (loopind+j-1)
tau2MCMC[j,i] = sampletau2mean(y-alphas,(BMCMC[predin,i]-muMCMC[j,i-1]))
muMCMC[j,i] = samplemumean(y-alphas,BMCMC[predin,i],sig2MCMC[i],tau2MCMC[j,i],m,sig02)
}
# sample prior parameter sigalpha2
sigmalpha2MCMC[i] = samplesigalpha2(alphaMCMC[,i-1])
# SAMPLE the country i level fixed effects (alphas)
for(j in 1:numi)
{
ind = alphaIDlist[[j]]
yxmB = y[ind] - X[ind,]%*%BMCMC[,i]
alphaMCMC[j,i] = samplealpha(yxmB,sigmalpha2MCMC[i])
}
}
m = 0
sig02 = 50
# other stuff
size = dim(X)[2]
numpred = size / (numi*numj)
BMCMC = matrix(0,size,loops)
sig2MCMC = rep(0,loops)
names(sig2MCMC) = rep('sig2',length(sig2MCMC))
tau2MCMC = matrix(0,numpred,loops)
muMCMC = matrix(0,numpred,loops)
alphaMCMC = matrix(0,numi,loops)
sigalpha2MCMC = rep(0,loops)
rownames(tau2MCMC) = paste('tau2',1:numpred)
rownames(muMCMC) = paste('mu',1:numpred)
# starting points for MCMC
BMCMC[,1] = rep(1,size)
sig2MCMC[1] = 1
tau2MCMC[,1] = rep(1,numpred)
muMCMC[,1] = rep(1,numpred)
alphaMCMC[,1] = rep(1,numi)
loopind = seq(from = 1,to = size,by = numpred)
#*************
## THE MCMC ##
#*************
for(i in 2:loops)
{
if(i%%50==0){print(noquote(paste('MCMC iter =',i)))}
# constructing fixed effect vector
alphas = rep(0,length(y))
for(j in 1:numi)
{
ind = alphaIDlist[[j]]
alphas[ind] = alphaMCMC[j,i-1]
}
# SAMPLE betas
BMCMC[,i] = as.numeric(sampleBmean(y-alphas,X,sig2MCMC[i-1],rep(tau2MCMC[,i-1],numi*numj),rep(muMCMC[,i-1],numi*numj)))
# SAMPLE sig2
sig2MCMC[i] = samplesig2mean(y-alphas,X,BMCMC[,i])
# SAMPLE the prior parameters on the betas .. mu and tau2 (both vectors)
for(j in 1:numpred)
{
predin = (loopind+j-1)
tau2MCMC[j,i] = sampletau2mean(y-alphas,(BMCMC[predin,i]-muMCMC[j,i-1]))
muMCMC[j,i] = samplemumean(y-alphas,BMCMC[predin,i],sig2MCMC[i],tau2MCMC[j,i],m,sig02)
}
# sample prior parameter sigalpha2
sigmalpha2MCMC[i] = samplesigmalpha2(alphaMCMC[,i-1])
# SAMPLE the country i level fixed effects (alphas)
for(j in 1:numi)
{
ind = alphaIDlist[[j]]
yxmB = y[ind] - X[ind,]%*%BMCMC[,i]
alphaMCMC[j,i] = samplealpha(yxmB,sigmalpha2MCMC[i])
}
}
# prior on mui
m = 0
sig02 = 50
# other stuff
size = dim(X)[2]
numpred = size / (numi*numj)
BMCMC = matrix(0,size,loops)
sig2MCMC = rep(0,loops)
names(sig2MCMC) = rep('sig2',length(sig2MCMC))
tau2MCMC = matrix(0,numpred,loops)
muMCMC = matrix(0,numpred,loops)
alphaMCMC = matrix(0,numi,loops)
sigmalpha2MCMC = rep(0,loops)
rownames(tau2MCMC) = paste('tau2',1:numpred)
rownames(muMCMC) = paste('mu',1:numpred)
# starting points for MCMC
BMCMC[,1] = rep(1,size)
sig2MCMC[1] = 1
tau2MCMC[,1] = rep(1,numpred)
muMCMC[,1] = rep(1,numpred)
alphaMCMC[,1] = rep(1,numi)
loopind = seq(from = 1,to = size,by = numpred)
for(i in 2:loops)
{
if(i%%50==0){print(noquote(paste('MCMC iter =',i)))}
# constructing fixed effect vector
alphas = rep(0,length(y))
for(j in 1:numi)
{
ind = alphaIDlist[[j]]
alphas[ind] = alphaMCMC[j,i-1]
}
# SAMPLE betas
BMCMC[,i] = as.numeric(sampleBmean(y-alphas,X,sig2MCMC[i-1],rep(tau2MCMC[,i-1],numi*numj),rep(muMCMC[,i-1],numi*numj)))
# SAMPLE sig2
sig2MCMC[i] = samplesig2mean(y-alphas,X,BMCMC[,i])
# SAMPLE the prior parameters on the betas .. mu and tau2 (both vectors)
for(j in 1:numpred)
{
predin = (loopind+j-1)
tau2MCMC[j,i] = sampletau2mean(y-alphas,(BMCMC[predin,i]-muMCMC[j,i-1]))
muMCMC[j,i] = samplemumean(y-alphas,BMCMC[predin,i],sig2MCMC[i],tau2MCMC[j,i],m,sig02)
}
# sample prior parameter sigalpha2
sigmalpha2MCMC[i] = samplesigmalpha2(alphaMCMC[,i-1])
# SAMPLE the country i level fixed effects (alphas)
for(j in 1:numi)
{
ind = alphaIDlist[[j]]
yxmB = y[ind] - X[ind,]%*%BMCMC[,i]
alphaMCMC[j,i] = samplealpha(yxmB,sigmalpha2MCMC[i])
}
}
